<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>redtecher</title>
    <link>https://redtecher.cn/</link>
    <description>Recent content on redtecher</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Mon, 29 Dec 2025 16:10:47 +0800</lastBuildDate>
    <atom:link href="https://redtecher.cn/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Emulation vs Rehosting</title>
      <link>https://redtecher.cn/posts/2025-12-29/</link>
      <pubDate>Mon, 29 Dec 2025 16:10:47 +0800</pubDate>
      <guid>https://redtecher.cn/posts/2025-12-29/</guid>
      <description>&lt;p&gt;固件仿真（Emulation）和重托管（Rehosting）是物联网（IoT）和嵌入式设备安全分析中两个紧密相关但侧重点不同的概念。为了帮助你快速把握核心区别，先用一个表格来对比它们的主要特征：&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;对比维度&lt;/th&gt;&#xA;          &lt;th&gt;固件仿真 (Emulation)&lt;/th&gt;&#xA;          &lt;th&gt;重托管 (Rehosting)&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;核心目标&lt;/td&gt;&#xA;          &lt;td&gt;精确模拟硬件执行环境（CPU、外设、指令）&lt;/td&gt;&#xA;          &lt;td&gt;在新的宿主环境中功能性运行固件，以完成特定分析任务&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;技术层次&lt;/td&gt;&#xA;          &lt;td&gt;偏向底层，关注指令翻译和硬件行为模拟&lt;/td&gt;&#xA;          &lt;td&gt;偏向高层，关注构建完整的虚拟运行环境&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;依赖方法&lt;/td&gt;&#xA;          &lt;td&gt;是重托管实现的一种基础手段&lt;/td&gt;&#xA;          &lt;td&gt;是一个更上层的概念和过程，常利用仿真作为其核心技术&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;范围与灵活性&lt;/td&gt;&#xA;          &lt;td&gt;通常模拟整个系统或特定硬件&lt;/td&gt;&#xA;          &lt;td&gt;可针对整个固件或特定模块，更具针对性&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;性能与开销&lt;/td&gt;&#xA;          &lt;td&gt;追求精确性时开销较大&lt;/td&gt;&#xA;          &lt;td&gt;通过高层抽象（如HLE）可显著提升效率&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;-深入理解概念&#34;&gt;🔍 深入理解概念&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;em&gt;固件仿真（Emulation）&lt;/em&gt; 的核心在于“模仿”。它通过软件创建一个虚拟的硬件环境，这个环境能够解释和执行原本为特定架构（如ARM、MIPS）编译的机器指令。常见的工具有QEMU（支持全系统仿真和用户态仿真）和Unicorn（专注于CPU指令模拟）。仿真的关键在于对硬件细节的还原度。&lt;/li&gt;&#xA;&lt;li&gt;&lt;em&gt;重托管（Rehosting）&lt;/em&gt; 的核心在于“迁移”和“运行”。它的最终目的不一定是百分百精确复制原始硬件行为，而是在新的宿主平台（如x86服务器）上，创造一个足以让固件或其关键模块“信以为真”并运行起来的环境，以便进行漏洞挖掘、动态分析等任务。重托管可以看作一个系统工程，它利用仿真作为基础，但会采用多种策略（特别是高层抽象）来应对硬件依赖的挑战。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;-实践中的技术策略&#34;&gt;🛠️ 实践中的技术策略&lt;/h2&gt;&#xA;&lt;p&gt;理解两者在具体技术实现上的不同，能帮你更好地把握其区别：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;重托管如何利用并超越仿真：重托管方案常常以QEMU这类仿真器作为底层执行基础。但为了成功运行固件，它需要解决大量的环境依赖问题，如缺失的硬件外设、不正确的内核配置等。因此，重托管框架会集成额外的技术，例如：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;高级仿真（HLE）：如HALucinator，通过识别并替换固件中的硬件抽象层（HAL）函数，用主机上的模拟实现来替代复杂的底层硬件交互，大幅提升效率。&lt;/li&gt;&#xA;&lt;li&gt;外设建模：如P²IM，尝试自动生成处理器与外设接口的通用模型。&lt;/li&gt;&#xA;&lt;li&gt;动态链接库劫持：例如使用LD_PRELOAD劫持NVRAＭ相关函数，提供模拟数据。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;所以，重托管是在仿真之上，构建了一整套应对环境差异的解决方案。&lt;/li&gt;&#xA;&lt;li&gt;仿真的角色：在重托管的上下文中，仿真更多是作为一种基础的、通用的指令执行引擎在发挥作用。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;-如何选择&#34;&gt;💡 如何选择？&lt;/h2&gt;&#xA;&lt;p&gt;在实际应用中，你的选择取决于分析目标：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果你需要精确研究固件在特定硬件上的底层行为，或者需要模拟整个操作系统环境，那么全系统仿真（如QEMU的系统模式）是更合适的选择。&lt;/li&gt;&#xA;&lt;li&gt;如果你的主要目标是高效地进行漏洞挖掘（如模糊测试）、动态分析固件逻辑，且可以接受一定的行为偏差，那么重托管框架（如SAFIREFUZZ, HALucinator）因其高性能和针对性优化，通常是更优的选择。&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
  </channel>
</rss>
